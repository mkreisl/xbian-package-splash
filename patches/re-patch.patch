diff --git a/Makefile b/Makefile
index 53715be..e232323 100644
--- a/Makefile
+++ b/Makefile
@@ -8,7 +8,7 @@ ifneq (, $(findstring arm, $(SYS)))
 		OSFLAGS = -Ofast -mfloat-abi=hard -mfpu=vfp -march=armv6 -Wconversion -Wunreachable-code -Wstrict-prototypes 
 	endif
 	ifneq (, $(findstring gnueabi, $(SYS)))
-		OSFLAGS = -Ofast -mfloat-abi=hard -mfpu=vfp -march=armv6 -Wconversion -Wunreachable-code -Wstrict-prototypes 
+		OSFLAGS = -Ofast -mfloat-abi=hard -Wconversion -Wunreachable-code -Wstrict-prototypes 
 	endif	
 	ifneq (, $(findstring gnueabisf, $(SYS)))
 		OSFLAGS = -Ofast -mfloat-abi=soft -mfpu=vfp -march=armv6 -Wconversion -Wunreachable-code -Wstrict-prototypes 
@@ -17,12 +17,12 @@ endif
 ifneq (, $(findstring amd64, $(SYS)))
 	OSFLAGS = -O3 -fPIC -march=native -mtune=native -mfpmath=sse -Wno-conversion
 endif
-CFLAGS = -ffast-math $(OSFLAGS) -Wfloat-equal -Wshadow -Wpointer-arith -Wcast-align -Wstrict-overflow=5 -Wwrite-strings -Waggregate-return -Wcast-qual -Wswitch-default -Wswitch-enum -Wformat=2 -g -Wall -isystem. -isystem.. -Ilibs/ -isystem/usr/include/ -isystem/usr/include/freetype2/
+CFLAGS = -g -ffast-math $(OSFLAGS) -Wfloat-equal -Wshadow -Wpointer-arith -Wcast-align -Wstrict-overflow=5 -Wwrite-strings -Waggregate-return -Wcast-qual -Wswitch-default -Wswitch-enum -Wformat=2 -g -Wall -isystem. -isystem.. -Ilibs/ -isystem/usr/include/ -isystem/usr/include/freetype2/
 SUBDIRS = libs
 SRC = $(wildcard *.c)
 INCLUDES = $(wildcard libs/*.h) $(wildcard libs/*.o)
 PROGAMS = $(patsubst %.c,splash-%,$(SRC))
-LIBS = libs/libs.o /usr/lib/arm-linux-gnueabihf/libjpeg.a /usr/lib/arm-linux-gnueabihf/libfreetype.a /usr/lib/arm-linux-gnueabihf/libz.a -lpthread
+LIBS = /usr/lib/arm-linux-gnueabihf/libfreetype.so libs/libs.o /usr/lib/arm-linux-gnueabihf/libjpeg.a /usr/lib/arm-linux-gnueabihf/libz.a -lpthread -lm
 
 .PHONY: subdirs $(SUBDIRS)
 
diff --git a/daemon.c b/daemon.c
index 8adc6f2..0c08603 100644
--- a/daemon.c
+++ b/daemon.c
@@ -534,8 +534,10 @@ void socket_parse_data(int i, char buffer[BUFFER_SIZE]) {
 			black = 1;
 			draw_loop = 0;
 			usleep((__useconds_t)speed);
-			main_draw_black();
+			fb_clear_mem();
+			fb_free_zmap();
 		} else {
+			fb_unblank();
 			main_draw();
 			black = 0;
 		}
@@ -543,6 +545,7 @@ void socket_parse_data(int i, char buffer[BUFFER_SIZE]) {
 		if(json_find_string(json, "percentage", &message) == 0) {
 			if(black == 1) {
 				progress_active = 0;
+				fb_unblank();
 				main_draw();
 				black = 0;
 			}
@@ -556,6 +559,7 @@ void socket_parse_data(int i, char buffer[BUFFER_SIZE]) {
 		} else if(json_find_string(json, "infinite", &message) == 0) {
 			if(black == 1) {
 				progress_active = 0;
+				fb_unblank();
 				main_draw();
 				black = 0;
 			}
@@ -576,6 +580,7 @@ void socket_parse_data(int i, char buffer[BUFFER_SIZE]) {
 				tmp_tpl = tmp_tpl->next;
 			}
 			if(black == 1) {
+				fb_unblank();
 				main_draw();
 				black = 0;
 			}
@@ -730,7 +735,7 @@ int main(int argc, char **argv) {
 	template_file = malloc(14);
 	strcpy(template_file, "template.json");
 
-	if((f = open(pid_file, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR)) != -1) {
+	if((f = open(pid_file, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) != -1) {
 		if(read(f, buffer, BUFFER_SIZE) != -1) {
 			//If the file is empty, create a new process
 			if(!atoi(buffer)) {
diff --git a/libs/Makefile b/libs/Makefile
index 8622463..4dce72f 100644
--- a/libs/Makefile
+++ b/libs/Makefile
@@ -5,10 +5,10 @@ ifneq (, $(findstring x86_64, $(SYS)))
 endif
 ifneq (, $(findstring arm, $(SYS)))
 	ifneq (, $(findstring gnueabihf, $(SYS)))
-		OSFLAGS = -Ofast -mfloat-abi=hard -mfpu=vfp -march=armv6 -Wconversion -Wunreachable-code -Wstrict-prototypes 
+		OSFLAGS = -Ofast -mfloat-abi=hard -Wconversion -Wunreachable-code -Wstrict-prototypes 
 	endif
 	ifneq (, $(findstring gnueabi, $(SYS)))
-		OSFLAGS = -Ofast -mfloat-abi=hard -mfpu=vfp -march=armv6 -Wconversion -Wunreachable-code -Wstrict-prototypes 
+		OSFLAGS = -Ofast -mfloat-abi=hard -Wconversion -Wunreachable-code -Wstrict-prototypes 
 	endif	
 	ifneq (, $(findstring gnueabisf, $(SYS)))
 		OSFLAGS = -Ofast -mfloat-abi=soft -mfpu=vfp -march=armv6 -Wconversion -Wunreachable-code -Wstrict-prototypes 
diff --git a/libs/config.h b/libs/config.h
index b106c19..1bb52fc 100644
--- a/libs/config.h
+++ b/libs/config.h
@@ -21,14 +21,14 @@ with Splash. If not, see <http://www.gnu.org/licenses/>
 #define _CONFIG_H_
 
 #define PORT 				9999
-#define MAX_CLIENTS			30
+#define MAX_CLIENTS			1
 #define BUFFER_SIZE			1025
 #define BIG_BUFFER_SIZE			1025
 #define ZINDEXES			4
 #define DEFAULT_FB			"/dev/fb0"
 
-#define PID_FILE			"/var/run/splash-daemon.pid"
-#define LOG_FILE			"/var/log/splash-daemon.log"
+#define PID_FILE			"/run/splash/splash.pid"
+#define LOG_FILE			"/run/splash-daemon.log"
 
 char *progname;
 
diff --git a/libs/fb.c b/libs/fb.c
index 84d1628..4b5db97 100644
--- a/libs/fb.c
+++ b/libs/fb.c
@@ -51,7 +51,7 @@ static struct fb_cmap ocmap = {0, 256, ored, ogreen, oblue};
 unsigned long screensize = 0;
 int fbfd = 0;
 int tty = 0;
-int orig_vt_no = 0;
+int orig_vt_no = 0, vtno = -1;
 int kd_mode;
 unsigned long fb_mem_offset = 0;
 
@@ -83,8 +83,23 @@ void fb_init_zmap(void) {
     }
 }
 
+void fb_free_zmap(void) {
+    size_t zindexes = ZINDEXES, width = fb_width(), height = fb_height();
+    int a = 0, b = 0;
+
+    if (zmap == NULL)
+        return;
+
+    logprintf(LOG_NOTICE, "freeing width %d, height %d, zindex %d.", width, height, zindexes);
+    for(a=0;a<zindexes;a++) {
+        for(b=0;b<width;b++)
+            free(zmap[a][b]);
+    }
+    zmap = NULL;
+}
+
 void fb_memset(void *addr, int c, size_t len) {
-#if 1
+#if 0
     unsigned int i, *p;
 
     i = (c & 0xff) << 8;
@@ -98,9 +113,9 @@ void fb_memset(void *addr, int c, size_t len) {
 }
 
 void fb_setvt(void) {
-	int vtno = -1;
     struct vt_stat vts;
     char vtname[12];
+    int i;
 
 	int cur_tty = open("/dev/tty0", O_RDWR);
 	if(cur_tty == -1) {
@@ -111,12 +126,15 @@ void fb_setvt(void) {
 	if(ioctl(cur_tty, VT_GETSTATE, &vts) == -1) {
 		logprintf(LOG_ERR, "VT_GETSTATE failed on /dev/tty0");
 		exit(EXIT_FAILURE);
+	} else {
+		logprintf(LOG_NOTICE, "VT open mask is %x", vts.v_state);
 	}
 
 	orig_vt_no = vts.v_active;
 
 	if(ioctl(cur_tty, VT_OPENQRY, &vtno) == -1) {
 		logprintf(LOG_ERR, "no open ttys available");
+		exit(EXIT_FAILURE);
 	}
 
 	if(close(cur_tty) == -1) {
@@ -124,28 +142,29 @@ void fb_setvt(void) {
 		exit(EXIT_FAILURE);
 	}
 
-    if(vtno < 0) {
-		if(ioctl(tty, VT_OPENQRY, &vtno) == -1 || vtno == -1) {
-			logprintf(LOG_ERR, "ioctl VT_OPENQRY");
-			exit(EXIT_FAILURE);
-		}
+	// look for free vt above tty3 as on tty2 we get getty with login later
+	for(i=4; i < 12; i++) {
+		if((vts.v_state & (1 << i)) == 0)
+			vtno = i;
+			break;
 	}
 
     vtno &= 0xff;
     sprintf(vtname, "/dev/tty%d", vtno);
-    chown(vtname, getuid(), getgid());
+//    chown(vtname, getuid(), getgid());
     if(access(vtname, R_OK | W_OK) == -1) {
 		logprintf(LOG_ERR, "access %s: %s\n", vtname,strerror(errno));
 		exit(EXIT_FAILURE);
     }
+    logprintf(LOG_NOTICE, "using tty %s", vtname);
 
     close(tty);
     close(0);
     close(1);
     close(2);
 
-	setsid();
-	open(vtname, O_RDWR);
+//	setsid();
+    tty = open(vtname, O_RDWR);
 	dup(0);
     dup(0);
 
@@ -168,6 +187,7 @@ void fb_setvt(void) {
 }
 
 void fb_cleanup(void) {
+
     if(ioctl(tty, KDSETMODE, kd_mode) == -1)
 		logprintf(LOG_ERR, "ioctl KDSETMODE");
 
@@ -201,12 +221,61 @@ void fb_clear_screen(void) {
 	fb_memset(fbp, 0, finfo.line_length * vinfo.yres);
 }
 
+void fb_unblank(void) {
+    unsigned long page_mask;
+
+    if(ioctl(tty, VT_ACTIVATE, vtno) == -1)
+	logprintf(LOG_ERR, "ioctl VT_ACTIVATE");
+    if(ioctl(tty, VT_WAITACTIVE, vtno) == -1)
+	logprintf(LOG_ERR, "ioctl VT_WAITACTIVE");
+
+/*    if(ioctl(tty, KDSETMODE, KD_TEXT | VT_PROCESS) == -1) {
+	logprintf(LOG_ERR, "ioctl KDSETMODE");
+    }
+    fb_clear_mem();
+*/
+    if(ioctl(tty, KDSETMODE, KD_TEXT) == -1) {
+	logprintf(LOG_ERR, "ioctl KDSETMODE");
+    }
+    if(ioctl(tty, KDSETMODE, KD_GRAPHICS | VT_PROCESS) == -1) {
+	logprintf(LOG_ERR, "ioctl KDSETMODE");
+    }
+
+    if(ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo) == -1) {
+		logprintf(LOG_ERR,"ioctl FBIOGET_VSCREENINFO");
+		exit(EXIT_FAILURE);
+    }
+    screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8;
+    munmap(fbp, finfo.smem_len+fb_mem_offset);
+
+    page_mask = (unsigned long)getpagesize()-1;
+ 
+    if(ioctl(fbfd, FBIOGET_FSCREENINFO, &finfo) == -1) {
+		logprintf(LOG_ERR, "ioctl FBIOGET_FSCREENINFO");
+		exit(EXIT_FAILURE);
+    }
+
+    if(zmap == NULL)
+	fb_init_zmap();
+
+    fb_mem_offset = (unsigned long)(finfo.smem_start) & page_mask;
+    fbp = (char *)mmap(0, finfo.smem_len+fb_mem_offset, PROT_READ | PROT_WRITE, MAP_SHARED, fbfd, 0);
+
+    if((int)fbp == -1) {
+        logprintf(LOG_ERR, "failed to map frame buffer device to memory");
+        exit(EXIT_FAILURE);
+    }
+
+    fb_clear_mem();
+
+}
+
 int fb_gc(void) {
+	fb_unblank();
 	fb_clear_mem();
 	fb_clear_screen();
 	fb_cleanup();
-	sfree((void *)&zmap);
-	close(fbfd);
+	fb_free_zmap();
 	return EXIT_SUCCESS;
 }
 
@@ -254,7 +323,7 @@ void fb_init(void) {
 		exit(EXIT_FAILURE);
     }
 
-    tcgetattr(tty, &term);
+//    tcgetattr(tty, &term);
 
     if(ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo) == -1) {
 		logprintf(LOG_ERR,"ioctl FBIOGET_VSCREENINFO");
@@ -277,7 +346,9 @@ void fb_init(void) {
         exit(EXIT_FAILURE);
     }
 
-	if(ioctl(tty, KDSETMODE, KD_GRAPHICS) == -1) {
+// don't lock console
+
+    if(ioctl(tty, KDSETMODE, KD_GRAPHICS | VT_PROCESS) == -1) { //VT_PROCESS
 	logprintf(LOG_ERR, "ioctl KDSETMODE");
 	fb_cleanup();
 	exit(EXIT_FAILURE);
@@ -330,7 +401,6 @@ void fb_put_pixel(int x, int y, int z, unsigned int color) {
 		color = 1;
 	}
 
-
 	if(z > -1) {
 		if(z > ZINDEXES) {
 			logprintf(LOG_ERR, "z-index out of range");
diff --git a/libs/fb.h b/libs/fb.h
index cc4bb52..b183207 100644
--- a/libs/fb.h
+++ b/libs/fb.h
@@ -22,10 +22,12 @@ Various functions used in this file are derived from fbi (Gerd Hoffmann <gerd@kr
 #ifndef _FB_H_
 #define _FB_H_
 
+void fb_free_zmap(void);
 void fb_memset(void *addr, int c, size_t len);
 void fb_setvt(void);
 void fb_cleanup(void);
 void fb_clear_mem(void);
+void fb_unblank(void);
 void fb_clear_screen(void);
 void fb_init(void);
 int fb_gc(void);
